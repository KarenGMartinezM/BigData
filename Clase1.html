<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hand Detection with Vector Operations</title>
  <!-- Karen Geraldine Martínez Moreno
       cod: 20221195001 -->

  <!-- Importa las bibliotecas de MediaPipe y utilidades de dibujo -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <!-- CSS minimalista para centrar el video y el lienzo -->
  <style>
    body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
    video, canvas { position: absolute; transform: rotateY(180deg); } /* Espeja el video y el lienzo */
  </style>
</head>
<body>

  <!-- Elementos de video y lienzo para detección en tiempo real -->
  <video id="webcam" autoplay playsinline></video>
  <canvas id="output_canvas"></canvas>

  <!-- JavaScript principal para la detección de puntos clave de las manos -->
  <script type="module">
    // Biblioteca para operaciones con vectores
    const Vector = {
      // Suma de dos vectores
      suma: function(v1, v2) {
        if (v1.length !== v2.length) {
          throw new Error("Los vectores deben tener la misma dimensión.");
        }
        return v1.map((value, index) => value + v2[index]);
      },
      // Multiplica un vector por un escalar
      escalarPorVector: function(scalar, vector) {
        return vector.map(value => value * scalar);
      },
      // Producto punto entre dos vectores
      productoPunto: function(v1, v2) {
        if (v1.length !== v2.length) {
          throw new Error("Los vectores deben tener la misma dimensión.");
        }
        return v1.reduce((sum, value, index) => sum + value * v2[index], 0);
      },
      // Calcula la magnitud de un vector
      magnitud: function(vector) {
        return Math.sqrt(vector.reduce((sum, value) => sum + value * value, 0));
      },
      // Calcula el coseno del ángulo entre dos vectores
      cosenoEntreVectores: function(v1, v2) {
        const productoPunto = this.productoPunto(v1, v2);
        const magnitudV1 = this.magnitud(v1);
        const magnitudV2 = this.magnitud(v2);
        return productoPunto / (magnitudV1 * magnitudV2);
      },
      // Calcula la distancia entre dos vectores
      distancia: function(v1, v2) {
        return Math.sqrt(v1.reduce((sum, value, index) => sum + Math.pow(value - v2[index], 2), 0));
      }
    };

    // Importa MediaPipe HandLandmarker
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    let handLandmarker;          // Instancia de detección de manos
    let runningMode = "VIDEO";    // Modo de ejecución: video en tiempo real
    let lastVideoTime = -1;       // Rastrea el tiempo del último frame procesado

    // Inicializa el detector de puntos clave de manos
    const initializeHandLandmarker = async () => {
      const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: runningMode,
        numHands: 2
      });
    };
    initializeHandLandmarker(); // Llama a la función para inicializar el detector

    const video = document.getElementById("webcam");           // Elemento de video de la cámara
    const canvas = document.getElementById("output_canvas");   // Lienzo para dibujar puntos clave
    const canvasCtx = canvas.getContext("2d");

    // Solicita acceso a la cámara web del usuario
    if (navigator.mediaDevices?.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
        video.srcObject = stream; // Configura el video para usar la cámara
        video.addEventListener("loadeddata", predictVideo); // Detecta puntos clave al cargar el video
      });
    }

    // Calcula vectores entre puntos clave de las falanges
    function calcularVectoresFalanges(landmarks) {
      // Cálculo de vectores entre articulaciones del índice, corazón, anular y meñique
      const indice = Vector.suma([landmarks[8].x, landmarks[8].y, landmarks[8].z], Vector.escalarPorVector(-1, [landmarks[7].x, landmarks[7].y, landmarks[7].z]));
      const corazon = Vector.suma([landmarks[12].x, landmarks[12].y, landmarks[12].z], Vector.escalarPorVector(-1, [landmarks[11].x, landmarks[11].y, landmarks[11].z]));
      const anular = Vector.suma([landmarks[16].x, landmarks[16].y, landmarks[16].z], Vector.escalarPorVector(-1, [landmarks[15].x, landmarks[15].y, landmarks[15].z]));
      const menique = Vector.suma([landmarks[20].x, landmarks[20].y, landmarks[20].z], Vector.escalarPorVector(-1, [landmarks[19].x, landmarks[19].y, landmarks[19].z]));
      
      // Calcula el coseno de los ángulos entre los vectores del índice y los otros dedos
      const cos_ind_cora = Vector.cosenoEntreVectores(indice, corazon);
      const cos_ind_anular = Vector.cosenoEntreVectores(indice, anular);
      const cos_ind_men = Vector.cosenoEntreVectores(indice, menique);

      // Suma de los cosenos calculados
      const suma_fal = cos_ind_cora + cos_ind_anular + cos_ind_men;

      // Valida si la suma de los cosenos indica una condición específica
      const validacion = suma_fal < -2.7;

      console.log("Validacion:", validacion); // Imprime el resultado de la validación

      return { validacion };
    }

    // Detecta puntos clave en cada frame del video
    async function predictVideo() {
      if (handLandmarker && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;

        // Configura las dimensiones del lienzo para que coincidan con el video
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        // Detecta puntos clave de manos en el frame actual
        const results = await handLandmarker.detectForVideo(video, performance.now());

        // Limpia los dibujos previos del lienzo
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

        // Dibuja los puntos clave detectados y sus conexiones
        if (results.landmarks) {
          for (const landmarks of results.landmarks) {
            const falanges = calcularVectoresFalanges(landmarks);

            // Dibuja un círculo amarillo si la validación es verdadera
            if (falanges.validacion) {
              const indexFingerTip = landmarks[8]; // Punta del dedo índice
              if (indexFingerTip) {
                const x = indexFingerTip.x * canvas.width;
                const y = indexFingerTip.y * canvas.height;

                // Dibuja un círculo amarillo en la punta del dedo índice
                canvasCtx.beginPath();
                canvasCtx.arc(x, y, 10, 0, 2 * Math.PI); // Radio del círculo = 10px
                canvasCtx.fillStyle = "yellow";
                canvasCtx.fill();
                canvasCtx.stroke();
              }
            }
          }
        }
      }
      // Continúa detectando en el siguiente frame
      requestAnimationFrame(predictVideo);
    }
  </script>
</body>
</html>
